import { basename, resolve } from 'node:path'
import { renderToString } from 'vue/server-renderer'
import { createApp } from '@/main'
import type { CTX, MetaReturn, RenderReturn, SSRManifest } from '#/ssr'
import { readFileSync } from 'node:fs'

/**
 * Create a link tag for a preload asset.
 *
 * @param {string} file
 *
 * @returns {string}
 */
const renderPreloadLink = (file: string): string => {
  if (file.endsWith('.js')) return `<link rel="modulepreload" crossorigin href="${file}"/>`

  if (file.endsWith('.css')) return `<link rel="stylesheet" href="${file}"/>`

  if (file.endsWith('.woff')) return `<link rel="preload" href="${file}" as="font" type="font/woff" crossorigin/>`
  if (file.endsWith('.woff2')) return `<link rel="preload" href="${file}" as="font" type="font/woff2" crossorigin/>`

  if (file.endsWith('.png')) return `<link rel="preload" href="${file}" as="image" type="image/png"/>`
  if (file.endsWith('.gif')) return `<link rel="preload" href="${file}" as="image" type="image/gif"/>`
  if (file.endsWith('.jpg') || file.endsWith('.jpeg')) {
    return `<link rel="preload" href="${file}" as="image" type="image/jpeg"/>`
  }

  return ''
}

/**
 * Create the link tags for preload assets. The links are generated from the manifest.
 * The SSR manifest generated by Vite contains module -> chunk/asset mapping which we can then use to determine
 * what files need to be preloaded for this request.
 *
 * @param {Set<string>} modules
 * @param {SSRManifest} manifest
 *
 * @returns {string}
 */
const renderPreloadLinks = (modules: Set<string>, manifest: SSRManifest) => {
  let links = ''
  const seen = new Set()

  modules.forEach((id) => {
    const files = manifest[id]

    if (files) {
      files.forEach(file => {
        if (!seen.has(file)) {
          seen.add(file)
          const filename = basename(file)

          if (manifest[filename]) {
            for (const depFile of manifest[filename]) {
              links += renderPreloadLink(depFile)
              seen.add(depFile)
            }
          }

          links += renderPreloadLink(file)
        }
      })
    }
  })

  return links
}

/**
 * Create the meta tags for the current request.
 *
 * @param {string} url
 *
 * @returns {MetaReturn}
 */
const renderMeta = (url: string): MetaReturn => {
  const data = JSON.parse(readFileSync(resolve('./src/meta/meta.json'), 'utf-8'))
  const title = data[url]?.title || 'Jojotique'
  let meta = ''

  for (const [name, content] of Object.entries(data[url]?.meta || {})) {
    if (typeof content === 'string') {
      meta += `<meta name="${name}" content="${content}"/>`
    } else if (typeof content === 'object') {
      for (let [key, value] of Object.entries(content as Record<string, string | Record<string, string>>)) {
        if (typeof value === 'string') {
          if (['url', 'image'].includes(key) && !value.startsWith('http')) {
            value = import.meta.env.VITE_APP_FRONT_URL + value
          }
          meta += `<meta name="${name}:${key}" content="${value}"/>`
        } else if (typeof value === 'object') {
          for (let [subKey, subValue] of Object.entries(value as Record<string, string>)) {
            if (['url', 'image'].includes(subKey) && !subValue.startsWith('http')) {
              subValue = import.meta.env.VITE_APP_FRONT_URL + subValue
            }
            meta += `<meta name="${name}:${key}:${subKey}" content="${subValue}"/>`
          }
        }
      }
    }
  }

  return {
    title,
    meta,
  }
}

/**
 * The function called by Vite each time a request is made to the server.
 * e.g. when a user visits a page in the browser in the "/" route or that the icon '/favicon.ico' is requested.
 *
 * @param {string} url
 * @param {SSRManifest} manifest
 *
 * @returns {Promise<string[]>}
 */
export async function render(url: string, manifest: SSRManifest): Promise<RenderReturn> {
  const { app, router } = createApp()

  // set the router to the desired URL before rendering
  await router.push(url)
  await router.isReady()

  // passing SSR context object which will be available via useSSRContext()
  // @vitejs/plugin-vue injects code into a component's setup() that registers
  // itself on ctx.modules. After the render, ctx.modules would contain all the
  // components that have been instantiated during this render call.
  const ctx: CTX = { modules: new Set() }
  const { title, meta } = renderMeta(url)

  const appHtml = await renderToString(app, ctx)

  const preloadLinks = renderPreloadLinks(ctx.modules, manifest)

  return {
    appHtml,
    ctx,
    meta,
    preloadLinks,
    title,
  }
}
